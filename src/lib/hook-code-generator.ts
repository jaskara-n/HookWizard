import type { HookFlags } from './mock-registry';

export function generateHookCode(flags: HookFlags, agentPrompt: string): string {
  const imports = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {BaseHook} from "v4-periphery/BaseHook.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";
import {IPoolManager} from "v4-core/interfaces/IPoolManager.sol";
import {PoolKey} from "v4-core/types/PoolKey.sol";
import {BalanceDelta} from "v4-core/types/BalanceDelta.sol";
import {Currency} from "v4-core/types/Currency.sol";`;

  const contractName = generateContractName(flags);
  
  const stateVars = generateStateVars(flags);
  const hookFlags = generateHookFlags(flags);
  const functions = generateFunctions(flags, agentPrompt);

  return `${imports}

/**
 * @title ${contractName}
 * @notice Custom Uniswap v4 Hook
 * @dev Generated by Hook Wizard
${agentPrompt ? ` * Agent Prompt: "${agentPrompt}"` : ''}
 */
contract ${contractName} is BaseHook {
${stateVars}
    constructor(IPoolManager _poolManager) BaseHook(_poolManager) {}

    function getHookPermissions() public pure override returns (Hooks.Permissions memory) {
        return Hooks.Permissions({
${hookFlags}
        });
    }
${functions}
}
`;
}

function generateContractName(flags: HookFlags): string {
  const parts: string[] = [];
  if (flags.dynamicFees) parts.push('DynamicFee');
  if (flags.limitOrders) parts.push('LimitOrder');
  if (flags.timeLock) parts.push('TimeLock');
  if (flags.whitelist) parts.push('Whitelist');
  return parts.length > 0 ? `${parts.join('')}Hook` : 'CustomHook';
}

function generateStateVars(flags: HookFlags): string {
  const vars: string[] = [];
  
  if (flags.dynamicFees) {
    vars.push('    uint24 public baseFee = 3000; // 0.3%');
    vars.push('    uint24 public maxFee = 10000; // 1%');
  }
  
  if (flags.limitOrders) {
    vars.push('    mapping(bytes32 => LimitOrder) public limitOrders;');
    vars.push('    struct LimitOrder { address owner; int24 tickLower; uint128 amount; }');
  }
  
  if (flags.timeLock) {
    vars.push('    uint256 public lockDuration = 1 days;');
    vars.push('    mapping(address => uint256) public unlockTime;');
  }
  
  if (flags.whitelist) {
    vars.push('    mapping(address => bool) public whitelist;');
    vars.push('    address public whitelistAdmin;');
  }
  
  return vars.length > 0 ? '\n' + vars.join('\n') + '\n' : '';
}

function generateHookFlags(flags: HookFlags): string {
  const allFlags = [
    'beforeInitialize', 'afterInitialize',
    'beforeAddLiquidity', 'afterAddLiquidity',
    'beforeRemoveLiquidity', 'afterRemoveLiquidity',
    'beforeSwap', 'afterSwap',
    'beforeDonate', 'afterDonate'
  ];
  
  const activeFlags = new Set<string>();
  
  if (flags.dynamicFees) {
    activeFlags.add('beforeSwap');
  }
  if (flags.limitOrders) {
    activeFlags.add('afterSwap');
    activeFlags.add('beforeSwap');
  }
  if (flags.timeLock) {
    activeFlags.add('beforeAddLiquidity');
    activeFlags.add('beforeRemoveLiquidity');
  }
  if (flags.whitelist) {
    activeFlags.add('beforeSwap');
    activeFlags.add('beforeAddLiquidity');
  }
  
  return allFlags
    .map(flag => `            ${flag}: ${activeFlags.has(flag)}`)
    .join(',\n');
}

function generateFunctions(flags: HookFlags, agentPrompt: string): string {
  const funcs: string[] = [];
  
  if (flags.dynamicFees) {
    funcs.push(`
    function _calculateDynamicFee(PoolKey calldata key) internal view returns (uint24) {
        // Dynamic fee based on volatility or other factors
        // TODO: Implement custom logic
        return baseFee;
    }`);
  }
  
  if (flags.limitOrders) {
    funcs.push(`
    function placeLimitOrder(
        PoolKey calldata key,
        int24 tickLower,
        uint128 amount
    ) external returns (bytes32 orderId) {
        orderId = keccak256(abi.encode(msg.sender, key, tickLower, block.timestamp));
        limitOrders[orderId] = LimitOrder(msg.sender, tickLower, amount);
    }`);
  }
  
  if (flags.timeLock) {
    funcs.push(`
    function beforeAddLiquidity(
        address sender,
        PoolKey calldata,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) external override returns (bytes4) {
        unlockTime[sender] = block.timestamp + lockDuration;
        return BaseHook.beforeAddLiquidity.selector;
    }
    
    function beforeRemoveLiquidity(
        address sender,
        PoolKey calldata,
        IPoolManager.ModifyLiquidityParams calldata,
        bytes calldata
    ) external override returns (bytes4) {
        require(block.timestamp >= unlockTime[sender], "TimeLock: locked");
        return BaseHook.beforeRemoveLiquidity.selector;
    }`);
  }
  
  if (flags.whitelist) {
    funcs.push(`
    function setWhitelist(address account, bool status) external {
        require(msg.sender == whitelistAdmin, "Not admin");
        whitelist[account] = status;
    }
    
    modifier onlyWhitelisted(address sender) {
        require(whitelist[sender], "Not whitelisted");
        _;
    }`);
  }
  
  if (agentPrompt) {
    funcs.push(`
    // =============================================================
    // AGENT-GENERATED LOGIC PLACEHOLDER
    // Prompt: "${agentPrompt}"
    // TODO: Implement custom logic based on natural language input
    // =============================================================`);
  }
  
  return funcs.join('\n');
}
